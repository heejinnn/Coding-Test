# [Silver III] 정수 a를 k로 만들기 - 25418 

[문제 링크](https://www.acmicpc.net/problem/25418) 

### 성능 요약

메모리: 92976 KB, 시간: 20 ms

### 분류

너비 우선 탐색, 다이나믹 프로그래밍, 그래프 이론, 그래프 탐색

### 제출 일자

2025년 4월 15일 00:14:06

### 문제 설명

<p>입력으로 양의 정수 <em>A</em>와 <em>K</em>가 주어지면, 아래 연산을 이용하여 <em>A</em>를 <em>K</em>로 변경하려고 한다. 정수 <em>A</em>를 변경할 때 사용할 수 있는 연산 종류는 다음과 같다.</p>

<ul>
	<li>연산 1: 정수 <em>A</em>에 1을 더한다.</li>
	<li>연산 2: 정수 <em>A</em>에 2를 곱한다.</li>
</ul>

<p>정수 <em>A</em>를 정수 <em>K</em>로 만들기 위해 필요한 최소 연산 횟수를 출력하자.</p>

### 입력 

 <p>첫 번째 줄에 양의 정수 <em>A</em>와 <em>K</em>가 빈칸을 사이에 두고 순서대로 주어진다.</p>

### 출력 

 <p class="0">첫 번째 줄에 양의 정수 <em>A</em>를 양의 정수 <em>K</em>로 만들기 위해 필요한 최소 연산 횟수를 출력한다.</p>

### ✏️ 문제 풀이

가장 적은 횟수로 도달하는 경로를 찾기 위해 BFS를 사용한다.

처음에 큐에 A를 넣고, visited 배열을 이용해서 이미 방문한 숫자는 다시 방문하지 않게 막는다.
그리고 BFS의 핵심인 레벨별 탐색을 위해 현재 큐의 크기만큼 반복해서 그 깊이의 숫자들을 처리한다.

각 숫자를 꺼내면서:

- 만약 그 숫자가 K라면, 지금까지 몇 번의 연산을 했는지(count)를 출력하고 종료
- 아니라면, +1과 *2 연산을 해서 나온 숫자들을 큐에 추가하고, 그 숫자들을 visited에 표시해 중복 탐색을 막는다. 

이 과정을 반복하면서 count를 하나씩 증가시키고, 결국 가장 먼저 K에 도달하는 순간이 가장 적은 연산이 된다.

